# Лабораторная работа 2: Работа с коллекциями

## Описание проекта

Проект реализует анализ и сравнение производительности операций над различными коллекциями:

- `List<T>`
- `LinkedList<T>`
- `Queue<T>`
- `Stack<T>`
- `ImmutableList<T>`

## Структура проекта

```
lab2/
├── Performance/              # Классы для замеров производительности
│   ├── ListPerformance.cs
│   ├── LinkedListPerformance.cs
│   ├── QueuePerformance.cs
│   ├── StackPerformance.cs
│   ├── ImmutableListPerformance.cs
│   ├── PerformanceMeasurer.cs
│   ├── PerformanceResult.cs
├── Tests/                    # Автоматизированные тесты
│   ├── ListTests.cs
│   ├── LinkedListTests.cs
│   ├── QueueTests.cs
│   ├── StackTests.cs
│   └── ImmutableListTests.cs
├── Program.cs                # Точка входа приложения
├── lab2.csproj              # Основной проект
└── lab2.Tests.csproj        # Проект тестов
```

## Запуск проекта

### Сборка проекта

```bash
dotnet build lab2.csproj
```

### Запуск замеров производительности

```bash
dotnet run --project lab2.csproj
```

### Запуск тестов

```bash
dotnet test lab2.Tests.csproj
```

## Реализованные операции

- **Добавление элементов**: в конец, в начало, в середину
- **Удаление элементов**: из начала, из конца, из середины
- **Поиск элемента** по значению
- **Получение элемента** по индексу (где применимо)

## Подход к реализации замеров

1. Использование `Stopwatch` для измерения времени выполнения
2. Каждая операция выполняется 5 раз с последующим усреднением результатов
3. Работа с коллекциями размером 100 000 элементов (для ImmutableList - 1000 из-за производительности)
4. Результаты выводятся в консоль в формате: `ТипКоллекции Операция: время мс`

## Ответы на вопросы для защиты

### 1. Почему List<T>.Insert(0, item) медленнее LinkedList<T>.AddFirst(item)?

`List<T>.Insert(0, item)` требует сдвига всех существующих элементов вправо на одну позицию, что имеет сложность O(n). `LinkedList<T>.AddFirst(item)` просто создает новый узел и обновляет ссылки, что имеет сложность O(1).

### 2. В каких случаях ImmutableList<T> предпочтительнее обычного List<T>?

- Когда нужна потокобезопасность без блокировок
- Когда требуется гарантия неизменности данных
- В функциональном программировании
- Когда нужно сохранить историю изменений (каждая операция создает новую версию)

### 3. Как List<T> реализует амортизированную O(1) для добавления?

`List<T>` использует динамический массив с резервированием памяти. При заполнении массива выделяется новый массив большего размера (обычно в 2 раза), элементы копируются, и старый массив освобождается. Хотя отдельные операции копирования имеют O(n), амортизированная сложность добавления остается O(1).

### 4. Почему поиск в LinkedList<T> медленнее, чем в List<T>?

`List<T>` использует массив, что позволяет прямой доступ по индексу O(1) и эффективный поиск. `LinkedList<T>` требует последовательного прохода по узлам от начала до нужного элемента, что дает O(n) для поиска.

### 5. Когда стоит использовать предварительное выделение Capacity?

Когда известно приблизительное или точное количество элементов, которые будут добавлены. Это позволяет избежать множественных перераспределений памяти и улучшает производительность.

### 6. Как Queue<T> реализует эффективное удаление из начала?

`Queue<T>` использует циклический массив (circular buffer) с указателями на начало и конец. Удаление из начала - это просто инкремент указателя начала, что дает O(1) сложность без необходимости сдвига элементов.

### 7. В чем разница между IEnumerable, ICollection и IList?

- **IEnumerable**: базовый интерфейс, предоставляет только перечисление элементов (метод `GetEnumerator()`)
- **ICollection**: наследует `IEnumerable`, добавляет `Count`, `Add`, `Remove`, `Clear`, `Contains`, `CopyTo`
- **IList**: наследует `ICollection`, добавляет индексированный доступ (`this[int]`), `Insert`, `RemoveAt`, `IndexOf`

### 8. Как выбор коллекции влияет на работу Garbage Collector?

- **List<T>**: создает массивы, которые могут быть большими объектами (LOH), что требует полной сборки мусора
- **LinkedList<T>**: создает множество маленьких объектов (узлов), увеличивает нагрузку на GC из-за частых сборок
- **ImmutableList<T>**: создает много промежуточных объектов при операциях, что увеличивает нагрузку на GC
- **Queue<T>** и **Stack<T>**: используют массивы, но обычно меньшего размера, чем `List<T>`

## Выводы

1. **List<T>** - лучший выбор для большинства случаев: эффективное добавление в конец, доступ по индексу, хорошая производительность поиска
2. **LinkedList<T>** - эффективен для частых операций вставки/удаления в начале и конце, но медленнее для поиска и доступа по индексу
3. **Queue<T>** - оптимизирован для FIFO операций
4. **Stack<T>** - оптимизирован для LIFO операций
5. **ImmutableList<T>** - следует использовать только когда необходима неизменяемость и потокобезопасность, так как операции значительно медленнее
